\documentclass{llncs}

\usepackage[dvipsnames]{xcolor}

\newenvironment{structure}{
  \begin{color}{ForestGreen}
}{
  \end{color}
}

\newcommand{\alg}[1]{\textup{\texttt{#1}}}

\begin{document}

\section{Introduction}

\begin{structure}
Outline target audience, presentation strategy (incremental requirements based on attacks), gap we fill, our emphasis on rigourous models
\end{structure}

\section{First steps}

\begin{structure}
motivating example, realisation (envelopes), security/trust models;
primitives required for crypto implementation, FOO
\end{structure}

\subsection{Example}

Here is one way to run a poll. Voters enter a polling station and pick up a voting card on which the candidates standing for election or choices in a referendum are printed. They fill in their card by placing crosses in boxes. Then they take their card and put it in an opaque envelope which they seal. In keeping with the cryptographic constructions we will describe later, we call such an envelope containing a filled in vote card a ``ballot''. This completes the first step, ballot creation.

To cast their ballots, voters present them to an official along with some identification. The official checks that the voter is registered at this polling station and has not cast a vote yet, but the official does not get to see the vote itself. Then the official places the ballot-envelope in a stamping machine and stamps the envelope, in such a way that the imprint of the stamp is not only visible on the envelope but also transferred to the vote card within.

Voters post their ballots to a counting centre. The postal service agrees to send any correctly stamped envelope free of charge from anywhere in the country so voters can post their envelope anonymously in any post box that they choose. 
The counting centre shuffles all received envelopes again, opens them and counts all vote cards that contain an imprint of the official stamp.

\subsection{Thinking about security}

\subsection{Cryptographic primitives}

\begin{structure}
\begin{itemize}
\item digital signatures
\item blind signatures
\item commitments
\end{itemize}
\end{structure}

\subsubsection{Digital signatures}

% DB: This is a new section (nothing to copy across like for encryption/PoKs) so
% I'll try making a first attempt at writing something for it now.

Digital signatures are the cryptographer's replacement for signatures or stamps.
If we know what someone's signature looks like and believe that it would be hard
for anyone but the owner to produce such a signature, the presence of such a
signature on a document attests that the owner has seen and signed it.
Similarly, the imprint of a stamp on a document attests that someone with the
appropriate stamp has seen the document.

Digital signatures differ from phyiscal ones in that they are not placed on an
original document, modifying the original, but are separate objects that can be
provided alongside the original. As a consequence, to prevent someone from
transferring a signature from one document to another, digital signatures for
different documents will be completely different objects.

To be able to create digital signatures, a signer first has to generate a pair
of keys called the signing key (or secret key) and verification key (or public
key). To do this, a digital signature scheme defines a key generation algorithm.
The signing key is like a stamp with which the signer can stamp documents. Such
a stamp on a document does not mean much on its own (anyone can create their own
stamps) but if you know what a particular person's or organisation's stamp looks
like, you can verify any stamped document to see if it was really stamped by the
person or organisation you know, by comparing the imprint on the document with
the imprint you know to be theirs. The verification key plays a similar role for
digital signatures.

A digital signature scheme comes with two more algorithms. The signing algorithm
takes a document and a signing key as input and returns a signature for the
document. The verification algorithm takes a document, a signature and a
verification key and outputs 1 if the signature is valid for the given key and
document, otherwise 0.

It is the signer's responsibility that all verifiers have an authentic copy of
the verification key. For example, in some government e-ID card schemes every
citizen gets a smartcard containing a signing key and the government maintains a
public database of verification keys. For a digital election, if the election
authorities need to sign ballots they can publish their verification key as part
of the election specification.

\begin{definition}
A digital signature scheme $\Sigma$ is a triple of algorithms
\[
\Sigma = \left( \alg{KeyGen}, \alg{Sign}, \alg{Verify} \right)
\]
known as the key generation, signing and verification algorithms and satisfying
the correctness condition below.

The key generation algorithm takes no input and produces a pair of keys $(sk,
vk) \gets \alg{KeyGen}()$ known as the signing and verification keys. The siging
algorithm takes a signing key $sk$ and a message $m$ as inputs and produces a
signature $\sigma \gets \alg{Sign}(sk, m)$. The verification algorithm must be
deterministic. It takes a verification key $vk$, a message $m$ and a signature
$\sigma$ as inputs and returns $0$ or $1$. We say that $\sigma$ is a (valid)
signature for $m$ under key $vk$ if $\alg{Verify}(vk, m, \sigma) = 1$.

A digital signature scheme must satisfy the following correctness condition
which means that correctly generated signatures are always valid. For any
message $m$, if you run the following sequence of algorithms then you get $b =
1$:
\[
(sk, vk) \gets \alg{KeyGen}();\ \sigma \gets \alg{Sign}(sk, m);\ b \gets \alg{Verify}(vk, m, \sigma)
\]
\end{definition}

This definition tells you what a digital signature scheme is and how to use it
but does not yet say anything about security. It is common in cryptography to
define a class of schemes in two parts, keeping functionality and security
separate. This has many advantages including that we can reason about several
different levels of security for the same class of schemes.



\subsection{The FOO protocol}

\section{Homomorphic Voting}

\subsection{Motivation and example}

\subsection{Asymmetric encryption}

\subsection{Minivoting}

\section{Privacy}

\begin{structure}
\begin{itemize}
\item bad ballots (solution: PoKs)
\item Cortier-Smyth attacks (solution: non-malleable ballots)
\item Trustee can decrypt individual ballots (solution: threshold)
\end{itemize}
\end{structure}

\subsection{Problems}

\subsection{Threshold encryption}

\section{Verifiability}

\section{Putting it all together}

% optional?
\section{Mix-nets}

\end{document}

